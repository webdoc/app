<!DOCTYPE html>
<html lang="en" class="js">
<head>
	<meta charset="utf-8" />
	<meta name="author" content="">
	<meta name="description" content="">
	
	<title>App API</title>
	
	<!-- Include template -->
	<link rel="stylesheet" type="text/css" href="http://webdoc.github.com/template/css/template.reset.css" />
	<link rel="stylesheet" type="text/css" href="http://webdoc.github.com/template/css/template.typography.css" />
	<link rel="stylesheet" type="text/css" href="http://webdoc.github.com/template/css/template.typography.12_18.css" />
	<link rel="stylesheet" type="text/css" href="http://webdoc.github.com/template/css/template.forms.css" />
	<link rel="stylesheet" type="text/css" href="http://webdoc.github.com/template/css/template.classes.css" />
	
	<link rel="stylesheet" type="text/css" href="css/doc.classes.css" />
</head>

<body>
	<div class="api_wrap wrap">




<section class="tab active anchor" id="intro">
	<h1>Introduction</h1>
	<h2 class="method_title anchor" id="what">What is a webdoc app?</h2>

	<p>A webdoc app is an application that can be used by authors to help create webdocs. It appears in the sidebar to the right of a webdoc when in edit mode. A webdoc app can place and modify items in a webdoc, display content that can be dragged and dropped onto a webdoc, and request information about a webdoc and it's author.

	<p>The app is displayed inside an iframe, so you have full control over how your app looks an behaves.



	<h2 class="method_title anchor" id="how">How to make a webdoc app</h2>

	<ol>
		<li>Grab a copy of the repository at http://github.com/webdoc/app. It has everything you need to get started:

  - A script tag that loads the webdoc app API.
  - A blank icon.png.
  - A config.xml file.
  - Links to CSS and JS for creating apps that look and behave like webdoc's apps.

		<li>Make an icon and place it in the root directory of your app. The icon must be a PNG file with square dimensions. 64px x 64px would be a good choice.

		<li>Study the API and get coding.

		<li>Upload the app the webdoc.com.
	</ol>

	<h2 class="method_title anchor" id="ul">How to upload your app to webdoc</h2>

	<ol>
		<li>Make sure you have an icon in your root directory.
		<li>Make sure that your config.xml file has your app's name, version and a reference to the index.html file of your app. It should look something like this:


<pre><code>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;app version=&quot;1.0&quot;&gt;        
  &lt;name&gt;my_app&lt;/name&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;description&gt;My app description&lt;/description&gt;
  &lt;content src=&quot;index.html&quot;/&gt; 
&lt;/app&gt;
</code></pre>

			<ul>
				<li><code>&lt;name&gt;</code> is used as the title of your app in webdoc, after having underscores replaced with spaces and the first letter capitalised.
				<li><code>&lt;version&gt;</code> must be a floating point number.
				<li><code>&lt;content&gt;</code> should have a src attribute that is a relative URL pointing to your app's index file.
			</ul>

		<li>Zip up all the files into one package, including all your CSS and JS.
		<li>upload the package at http://webdoc.com/admin.
	</ol>


	<p>You can also host your app yourself

	<p>Follow the instructions above, but at step 2 the<code>&lt;content&gt;</code> src attribute should be an absolute URL pointing to the index file where your app is hosted, and at step 3 your Zip package can contain simply the files config.xml and icon.png.
</section>


<section class="tab anchor" id="prop">
	<h1>Properties</h1>
	
		<h2 class="method_title anchor" id="user_prop">.user</h2>
	
	<p>Object that represents the current user. A user object may have the following properties:</p>

			<dl>
				<dt>avatar_thumb_url
				<dt>bio
				<dt>birthday
				<dt>created_at
				<dt>documents_count
				<dt>first_name
				<dt>followers_count
				<dt>following_count
				<dt>gender
				<dt>has_facebook_token
				<dt>has_the_orchard_account
				<dt>has_twitter_token
				<dt>id
				<dt>is_admin
				<dt>is_safe
				<dt>last_name
				<dt>registration
				<dt>user_type
				<dt>username
				<dt>uuid
				<dt>website
			</dl>
		</dd>

		<h2 class="method_title anchor" id="host_prop">.host</h2>
		<p>Domain name where the app is hosted.</p>

		<h2 class="method_title anchor" id="lang_prop">.lang</h2>
		<p>The current language that webdoc's user interface is set to. Note that this is not the language that the webdoc may be written in.</p>
</section>




<section class="tab anchor" id="methods">
	<h1>Methods</h1>
	<h2 class="method_title anchor" id="ready_method" data-title=".ready()">.ready(fn)</h2>

<p>The app API loads in two stages. Functions passed into .ready() will be fired as soon as the full app API is ready to use. If the app API is already ready, the passed function will fire immediately.

<p>Note that this does not mean that the DOM is ready.



<h2 class="method_title anchor" id="bind_method" data-title=".bind()">.bind(type, function)</h2>

<p>Bind a handler function to be called whenever an event of type is emitted by webdoc. For a full list of events, see webdoc events.



<h2 class="method_title anchor" id="unbind_method" data-title=".unbind()">.unbind(type [, function])</h2>

<p>Unbind a handler function from events of this type. Where more than one instance of the given handler function is bound to the event, they are all removed.

<p>If no function is provided, all handler functions are unbound from this event.



<h2 class="method_title anchor" id="image_method" data-title=".insertImage()">.insertImage(url, [position])</h2>

<p>Inserts an image into the webdoc. URL is the path to the image to be inserted.

<p>If an optional position object is passed the image will be inserted at that position, otherwise the position will be calculated automatically. A position object should look like this:</p>

<pre><code>{
  top: n,
  left: m
}</code></pre>

<p>...where values for n and m are distances in pixels.



<h2 class="method_title anchor" id="item_method" data-title=".insertItem()">.insertItem(url, [position])</h2>

<p>Inserts an item into the webdoc. The type of item is determined by the resource that the URL points to. If it is a YouTube link, the item will be a video. If it is an image, the item will be an image.

<p>Webdoc accepts various item types:</p>

<ul>
<li>Image
<li>Video
<li>Googlemap
</ul>

<p>If an optional position object is passed the image will be inserted at that position, otherwise the position will be calculated automatically.



<h2 class="method_title anchor" id="insert_method" data-title=".insertWidget()">.insertWidget(name, preferences, [position])</h2>

<p>Inserts a widget into a webdoc, where name is the widget's name and preferences is key value object of options to pass to the widget.

<p>If an optional position object is passed the image will be inserted at that position, otherwise the position will be calculated automatically.

<p>See webdoc widgets for a list of widgets and their preferences.




<h2 class="method_title anchor" id="into_method" data-title=".insertIntoItem()">.insertIntoItem(url [, contentType])</h2>

<p>Some items in a webdoc have content that is editable. This method allows you to insert more content into them.




<h2 class="method_title anchor" id="fb_method" data-title=".fbGraphAPI()">.fbGraphAPI(path, verb, params, callback)</h2>

<p>When the current user is connected to Facebook, fbGraphAPI returns some data about his facebook something.




<h2 class="method_title anchor" id="t_method" data-title=".t()">.t(key, options)</h2>

<p>A function for translating strings.



<h2 class="method_title anchor" id="t_method" data-title=".request()">.request(url, options)</h2>

<p>The request method allow you to made cross domain request by passing through the webdoc proxy. It return both the response and the header.

<p>The options object can have the following properties:

<dl>
<dt>type</dt><dd>'GET' by default</dd>
<dt>data</dt><dd>object of key-value pairs to be added to the request</dd>
<dt>postData</dt><dd>object</dd>
<dt>callback</dt><dd>fn(data), called with a single object as an argument on completion of the request. The data object has the properties:
<dl>
<dt>status</dt><dd>The status code of the response (200, 404, ...)
<dt>response</dt><dd>The data returned from the server (HTML, XML, JSON, ...)
<dt>header</dt><dd>An object containing the header returned by the proxy
</dl>
</dd>
</dl>

</section>


<section class="tab anchor" id="events">
	<h1>Events</h1>
	
	<dl class="events_dl">
		<dt class="anchor" id="ready_event">ready</dt>
		<dd>
			<p>The ready event fires when the full webdoc app API is available.

			<p>See also the .ready() method, which will call callbacks immediately if the app is already in ready state.
		</dd>
		
		<dt class="anchor" id="sel_event">selectionchange</dt>
		<dd>
			<p>Triggered when the selected items in the webdoc change. Handler functions are passed one argument: an array of currently selected items. If the selection has changed so that nothing is selected, the array will be empty.
		</dd>
	</dl>
</section>

<section class="tab anchor" id="dnd">
	<h1>Preparing items for drag and drop</h1>
	
	<p>If you want to display items that the user can drag onto their webdoc, you need to give them some data that webdoc will understand. Normally, you would do this using the browser's drag and drop API. The drag and drop API requires that data is set on nodes when the dragstart event is received. The data you set depends on the mimetype that you want to send with the dragged node. Some browsers respond to some mimetypes, some to only one or two. It's all a bit of a hassle to set up.
	
	<p>The webdoc app template provides a shortcut to make this easy. To create a draggable node in your webdoc app:

	<ol>	
		<li>Give the node the boolean attribute <code>draggable="draggable"</code>
		<li>Attach the data to send either by defining a JSON object in a data-mimetypes attribute:
			<pre><code>
&lt;div draggable=&quot;draggable&quot; data-mimetypes='{&quot;wd-image&quot;:&quot;http://webdoc.com/stelio.gif&quot;,&quot;text/uri-list&quot;:&quot;http://webdoc.com/stelio.gif&quot;}'&gt;Drag me!&lt;/div&gt;
</code></pre>
	...or alternatively by setting mimetypes data via jQuery:
	<pre><code>
jQuery(node).data('mimetypes', {
  'wd-image': 'http://webdoc.com/stelio.gif',
  'text/uri-list': 'http://webdoc.com/stelio.gif'
});
</code></pre>
	
	You can specify as many mimetypes as you like, but for compatibility across all browsers at the very least a <code>text/uri-list</code> mimetype should be defined.
		</li>
	</ol>
	
	<p>That's it. The app template will now take care of sending this data when the node is dragged.
	
	<h2 class="method_title anchor" id="mimetypes">Custom mimetypes</h2>
	
	<p>Webdoc accepts the following custom mimetypes and associated data:

<pre><code>
application/wd-widget: {
  system_name: the system name of the widget to insert
  preferences: a json with widget preferences
}

application/wd-image: {
  url
}

application/wd-video {
  video_id: the url to the video (can be vimeo, youtube or other supported video services)
  title: the title of the video (optional)
}

application/wd-music {
  url: the url of a resource on SoundCloud
}

text/uri-list: url
</code></pre>
	
	<p>For more on the standard drag and drop API, visit the <a href="https://developer.mozilla.org/en/DragDrop/Drag_and_Drop">Mozilla Development Network</a>.
</section>


<section class="tab anchor" id="styling">
	<h1>Styling</h1>
	
	<iframe class="app_example example" src="index.html"></iframe>
	
</section>

		
		<nav class="api_nav nav" id="nav"></nav>
	</div>
	
	<!-- Include jQuery -->
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>
	<script>!window.jQuery && document.write(unescape('%3Cscript src="js/jquery.js"%3E%3C/script%3E'));</script>

	<!-- Include template -->
	<script src="http://webdoc.github.com/template/js/js.extensions.js"></script>
	<script src="http://webdoc.github.com/template/js/js.details.js"></script>
	<script src="http://webdoc.github.com/template/js/jquery.extensions.js"></script>
	<script src="http://webdoc.github.com/template/js/jquery.event.activate.js"></script>
	<script src="http://webdoc.github.com/template/js/jquery.validator.js"></script>
	<script src="http://webdoc.github.com/template/js/jquery.transitions.js"></script>
	<script src="http://webdoc.github.com/template/js/jquery.loading.js"></script>
	<script src="http://webdoc.github.com/template/js/template.ui.js"></script>
	
	<script type="text/javascript">
		
		
		// jQuery.tree
		// 
		// Construct a tree out of any selector. Returns a deep array-like
		// object that represents the tree described by all the nodes of
		// this selector found inside node. Alternatively, if a callback
		// function is defined, returns the result of the callback.
		// 
		// jQuery.tree(node, selector, callback)
		// 
		// The callback is called with the arguments (tree, n), where n is
		// the total number of nodes in the tree.
		
		jQuery.tree = function tree(node, selector, fn) {
			var anchors = jQuery(node).find(selector),
			    l = anchors.length,
			    n = -1,
			    array = {
			    	length: 0,
			    	node: node
			    };
			
			while (++n < l) {
				tree(anchors[n], selector, function(subArray, m) {
					Array.prototype.push.call(array, subArray);
					n = n + m;
				});
			}
			
			return fn ? fn(array, n) : array ;
		};
		
		
		// -------------
		// 
		// Automatically construct navigation bar from the document tree
		
		
		var tree = jQuery.tree(document.body, '.anchor'),
		    nav = jQuery('#nav'),
		    item = '<li><a class="menu_button button" href="#{{id}}">{{title}}</a>{{sub}}</li>';
		
		function renderList(tree) {
			var args = Array.prototype.slice.call(arguments, 1),
			    className = args.shift(1),
			    html = '<ul ' + (className ? 'class="' + (className) + '" ' : '') + '>',
			    n = -1,
			    l = tree.length,
			    node, entry, params, elem, title;
			
			while (++n < l) {
				entry = tree[n];
				node = entry.node;
				elem = jQuery(node);
				title = elem.children('h1, h2, h3, h4').eq(0);
				params = {
					id: node.id,
					title: elem.data('title') || (title.length ? title.html() : elem.html())
				};
				
				if (entry.length) {
					args.splice(0, 0, entry);
					params.sub = renderList.apply(this, args)
				}
				
				html += jQuery.render(item, params);
			}
			
			html += '</ul>';
			
			return html;
		}
		
		nav.html(renderList(tree, 'nav_index index'));
	</script>
</body>
</html>